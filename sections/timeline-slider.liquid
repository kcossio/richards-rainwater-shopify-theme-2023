{{ 'section-timeline-slider.css' | asset_url | stylesheet_tag }}

<h2 class="timeline-heading">{{ section.settings.heading }}</h2>

<div class="slider timeline-slider">
  {% assign count = 0 %}
  {%- for block in section.blocks -%}
    {% assign count = count | plus: 1 %}
    {%- case block.type -%}

      {%- when 'timeline_slide' -%}
        
        

        

    {%- endcase -%}
  {%- endfor -%}

<div class="timeline-scroller">
  
        
  <div class="wrapper timeline-wrap d-flex horiz-scroll flex-nowrap">
    {% assign count = 0 %}
  {%- for block in section.blocks -%}
      {% assign count = count | plus: 1 %}
      {%- case block.type -%}
    
        {%- when 'timeline_slide' -%}
      <section id="tl-section-{{ count }}" class="section timeline-block section--large flex-shrink-0 vw-100 vh-100 d-flex justify-content-center align-items-center one" data-year="{{ block.settings.year }}">
        <h3>{{ block.settings.title }} </h3>
        {{ block.settings.content }} 
        <div class="bg-img bg-hero">
          {%- assign hero_image = block.settings.hero_image -%}
          {%- if hero_image != blank -%}
          {{ hero_image | image_url: width: hero_image.width | image_tag: class: 'bg', loading: 'lazy' }}
          {%- endif -%}
        </div>
      </section>
    {%- endcase -%}
  {%- endfor -%}
  </div>

  <nav class="hor">
    {% assign count = 0 %}
    {%- for block in section.blocks -%}
      {% assign count = count | plus: 1 %}
      {%- case block.type -%}
        {%- when 'timeline_slide' -%}
          <div class="hash" data-link="#tl-section-{{ count }}">{{ block.settings.year }}</div>
      {%- endcase -%}
    {%- endfor -%}
  </nav>
  
</div><!--End timeline-scroller-->


<script>

  window.addEventListener("load", (event) => {

    let container = document.querySelector(".timeline-wrap")
    let scrollContainer = document.querySelector(".timeline-scroller");
    let sections = gsap.utils.toArray(".timeline-block");
    let maxWidth = 0;

    const getMaxWidth = () => {
      maxWidth = 0;
      sections.forEach((section) => {
        maxWidth += section.offsetWidth;
      });
    };
getMaxWidth();
ScrollTrigger.addEventListener("refreshInit", getMaxWidth);

// GSAP create horizontal scroll
let horizontalScroll = gsap.to(sections, {
  x: () => `-${maxWidth - window.innerWidth}`,
  ease: 'none',
  scrollTrigger: {
    trigger: scrollContainer,
    pin: true,
    scrub: true,
    end: () => `+=${maxWidth}`,
    invalidateOnRefresh: true,
  }
});

let getPosition = getScrollLookup(".timeline-block", {start: "center center", containerAnimation: horizontalScroll});

gsap.utils.toArray("nav.hor div").forEach(el => {
  el.addEventListener("click", e => {
    e.preventDefault();
    jQuery('.nav.hor div').removeClass('active');
    jQuery(el).addClass('active');
    gsap.to(window, {
      scrollTo: getPosition(el.getAttribute("data-link")),
      overwrite: "auto",
      duration: 1
    });
  });
});

/*
Returns a FUNCTION that you can feed an element to get its scroll position.
- targets: selector text, element, or Array of elements 
- config: an object with any of the following optional properties: 
    - start: defaults to "top top" but can be anything like "center center", "100px 80%", etc. Same format as "start" and "end" ScrollTrigger values.
    - containerAnimation: the horizontal scrolling tween/timeline. Must have an ease of "none"/"linear".
    - pinnedContainer: if you're pinning a container of the element(s), you must define it so that ScrollTrigger can make the proper accommodations.
*/
function getScrollLookup(targets, {start, pinnedContainer, containerAnimation}) {
  let triggers = gsap.utils.toArray(targets).map(el => ScrollTrigger.create({
        trigger: el,
        start: start || "top top",
        pinnedContainer: pinnedContainer,
        refreshPriority: -10,
        containerAnimation: containerAnimation
      })),
      st = containerAnimation && containerAnimation.scrollTrigger;
  return target => {
    let t = gsap.utils.toArray(target)[0],
        i = triggers.length;
    while (i-- && triggers[i].trigger !== t) {};
    if (i < 0) {
      return console.warn("target not found", target);
    } 
    return containerAnimation ? st.start + (triggers[i].start / containerAnimation.duration()) * (st.end - st.start) : triggers[i].start;
  };
}

    /*let sections = gsap.utils.toArray("section.timeline-block"),
      nav = gsap.utils.toArray("nav div"),
      getMaxWidth = () => sections.reduce((val, section) => val + section.offsetWidth, 0),
      maxWidth = getMaxWidth(),
      scrollSpeed = 4,
      snapProgress,
      lastScrollTween = Date.now(),
      tl = gsap.timeline();

    tl.to(sections, {
    x: () => window.innerWidth - maxWidth,
    duration: 1,
    ease: "none"
    });

    //Create the scrolltrigger
    ScrollTrigger.create({
    animation: tl,
    trigger: ".timeline-wrap",
    pin: true,
    scrub: 1,
    snap: {snapTo: directionalSnap(tl), duration: 0.5},
    end: () => "+=" + maxWidth / scrollSpeed,
    invalidateOnRefresh: true
    });


    function init() {
    gsap.set(sections, {x: 0});
    maxWidth = getMaxWidth();
    let position = 0,
        distance = maxWidth - window.innerWidth;
    // add a label for each section to the timeline (for "labelsDirectional" functionality):
    tl.add("label0", 0);
    sections.forEach((section, i) => {
      let progress = position;
      position += section.offsetWidth / distance;
      tl.add("label" + (i+1), position);
      nav[i].onclick = () => { // link clicks should trigger a scroll tween to the appropriate spot
        snapProgress = progress; // save the current progress so that if we can return it in the directionalSnap() when called right after the scrollTo tween is done (because ScrollTrigger would normally look at the velocity and snap, causing it to overshoot to the next section)
        lastScrollTween = Date.now(); // for checking in the directionalSnap() if there was a recent scrollTo that finished, in which case we'd skip the snapping (well, return the current snapProgress)
        gsap.to(window, {scrollTo: maxWidth / scrollSpeed * progress, duration: 1, overwrite: "auto"});
      };
    });
    }

    init();
    ScrollTrigger.addEventListener("refreshInit", init); // on resize, things must be recalculated

    // a helper function for doing "labelsDirectional" snapping, but we can't use that directly since we're doing some special things with scrollTo tweens, and we need a way to skip the snap if a scrollTo recently finished (otherwise it'll overshoot to the next section)
    function directionalSnap(timeline) {
      return (value, st) => {
        if (Date.now() - lastScrollTween < 1650) { // recently finished doing a tweened scroll (clicked link), so don't do any snapping.
          return snapProgress;
        }
        let a = [],
          labels = timeline.labels,
          duration = timeline.duration(),
          p, i;
        for (p in labels) {
          a.push(labels[p] / duration);
        }
        a.sort((a, b) => a - b);
        if (st.direction > 0) {
          for (i = 0; i < a.length; i++) {
            if (a[i] >= value) {
              return a[i];
            }
          }
          return a.pop();
        } else {
          i = a.length;
          while (i--) {
            if (a[i] <= value) {
              return a[i];
            }
          }
        }
        return a[0];
      };
    }

    */

  });
  

</script>

</div><!--End slider timeline-slider-->

{% schema %}
  {
  "name": "Timeline Slider",
  "class": "section-timeline slider-timeline-wrap",
  "tag": "section",
  "settings": [
    {
      "type": "text",
      "id": "heading",
      "label": "Heading",
      "info": "Add a heading for this timeline slider"
    }
  ],
  "blocks": [
    {
      "name": "Timeline Slide",
      "type": "timeline_slide",
      "settings": [
        {
          "type": "image_picker",
          "id": "hero_image",
          "label": "Hero Image",
          "info": "Upload or choose a hero image for this slide"
        },
        {
          "type": "text",
          "id": "year",
          "label": "Year",
          "info": "Enter a year for this slide.  This will be used to create the slide navigation"
        },
        {
          "type": "text",
          "id": "title",
          "label": "Title",
          "info": "Enter a title for the slide"
        },
        {
          "type": "textarea",
          "id": "content",
          "label": "Content",
          "info": "Add a short piece of text content for the slide"
        }
      ]
    }
  ],
  "presets": [
    {
      "name": "Timeline Slider"
    }
  ]
}  
{% endschema %}

{% stylesheet %}
{% endstylesheet %}

{% javascript %}
{% endjavascript %}